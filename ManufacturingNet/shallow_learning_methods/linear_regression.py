from math import sqrt
import matplotlib.pyplot as plt
from sklearn.linear_model import LinearRegression
from sklearn.metrics import mean_squared_error, r2_score
from sklearn.model_selection import cross_val_score, train_test_split

class LinRegression:
    """
    Class framework for linear regression model. Per scikit-learn's documentation:

    LinearRegression fits a linear model with coefficients to minimize the residual sum of squares between the observed
    targets in the dataset, and the targets predicted by the linear approximation.
    """

    def __init__(self, attributes=None, labels=None):
        """
        Initializes a LinearRegression object.

        The following parameters are needed to create a linear regression model:

            – attributes: a numpy array of the desired independent variables
            – labels: a numpy array of the desired dependent variables
            – test_size: the proportion of the dataset to be used for testing the model (defaults to 0.25);
            the proportion of the dataset to be used for training will be the complement of test_size
            – fit_intercept: determines whether to calculate the intercept for the model (defaults to True)
            – normalize: determines whether to normalize the dataset (defaults to False, ignored when fit_intercept
            is False)
            – copy_X: will copy the dataset's features if True (defaults to True)
            – n_jobs: the number of jobs to use for the computation (defaults to None)
            – cv: the number of folds to use for cross validation of model (defaults to None)
            – graph_results: determines if line of best fit will be graphed (defaults to False)

        The following instance data is found after successfully running run():

            – regression: The linear regression model object
            – coefficients: an array of coefficients that most closely satisfy the linear relationship between the
            independent and dependent variables
            – intercept: the y-intercept of the regression line generated by the model
            – mean_squared_error: the average squared difference between the estimated and actual values
            – r2_score: the coefficient of determination for this linear model
            – r_score: the correlation coefficient for this linear model
            – cross_val_scores: the cross validation score(s) for this linear model
        """
        self.attributes = attributes
        self.labels = labels

        self.test_size = None
        self.cv = None
        self.graph_results = None

        self.regression = None
        self.coefficients = None
        self.intercept = None
        self.mean_squared_error = None
        self.r2_score = None
        self.r_score = None
        self.cross_val_scores = None

    # Accessor methods

    def get_attributes(self):
        """
        Accessor method for attributes.

        If a LinearRegression object is initialized without specifying attributes, attributes will be None.
        run() cannot be called until attributes is a numpy array of independent variables; call
        set_attributes(new_attributes) to fix this.
        """
        return self.attributes

    def get_labels(self):
        """
        Accessor method for labels.

        If a LinearRegression object is initialized without specifying labels, labels will be None.
        run() cannot be called until labels is a numpy array of dependent variables;
        call set_labels(new_labels) to fix this.
        """
        return self.labels

    def get_test_size(self):
        """
        Accessor meethod for test_size.

        Should return a number or None.
        """
        return self.test_size

    def get_regression(self):
        """
        Accessor method for regression.

        Will return None if run() hasn't been called, yet.
        """
        return self.regression

    def get_coefficients(self):
        """
        Accessor method for coefficients that satisfy regression model.

        Will return None if run() hasn't been called, yet.
        """
        return self.coefficients

    def get_intercept(self):
        """
        Accessor method for intercept of regression line.

        Will return None if run() hasn't been called, yet.
        """
        return self.intercept

    def get_mean_squared_error(self):
        """
        Accessor method for mean squared error of linear regression model.

        Will return None if run() hasn't been called, yet.
        """
        return self.mean_squared_error

    def get_r2_score(self):
        """
        Accessor method for coefficient of determination of linear regression model.

        Will return None if run() hasn't been called, yet.
        """
        return self.r2_score

    def get_r_score(self):
        """
        Accessor method for correlation coefficient of linear regression model.

        Will return None if run() hasn't been called, yet.
        """
        return self.r_score
    
    def get_cross_val_scores(self):
        """
        Accessor method for cross validation score of linear regression model.

        Will return None if run() hasn't been called, yet.
        """
        return self.cross_val_scores

    # Modifier methods

    def set_attributes(self, new_attributes=None):
        """
        Modifier method for attributes.

        Input should be a numpy array of independent variables. Defaults to None.
        """
        self.attributes = new_attributes

    def set_labels(self, new_labels=None):
        """
        Modifier method for labels.

        Input should be a numpy array of dependent variables. Defaults to None.
        """
        self.labels = new_labels

    # Wrapper for linear regression model

    def run(self):
        """
        Performs linear regression on dataset and updates relevant instance data.
        """
        if self._check_inputs():
            # Instantiate LinearRegression() object using helper method
            self.regression = self._create_model()

            # Split into training and testing sets
            dataset_X_train, dataset_X_test, dataset_y_train, dataset_y_test =\
                train_test_split(self.attributes, self.labels, test_size=self.test_size)

            # Train the model and get resultant coefficients; handle exception if arguments aren't correct
            try:
                self.regression.fit(dataset_X_train, dataset_y_train)
            except Exception as e:
                print("An exception occurred while training the regression model. Check your inputs and try again.")
                print("Here is the exception message:")
                print(e)
                self.regression = None
                return

            # Get resultant coefficients and intercept of regression line
            self.coefficients = self.regression.coef_
            self.intercept = self.regression.intercept_

            # Make predictions using testing set
            y_prediction = self.regression.predict(dataset_X_test)

            # Get mean squared error, coefficient of determination, correlation coefficient, and cross validation score
            self.mean_squared_error = mean_squared_error(dataset_y_test, y_prediction)
            self.r2_score = r2_score(dataset_y_test, y_prediction)
            self.r_score = sqrt(self.r2_score)
            self.cross_val_scores = cross_val_score(self.regression, self.attributes, self.labels, cv=self.cv)

            # Output results
            self._output_results()

            # Plot results, if desired
            if self.graph_results:
                self._graph_results(dataset_X_test, dataset_y_test, y_prediction)
    
    def predict(self, dataset_X=None):
        """
        Predicts the output of each datapoint in dataset_X using the regression model.

        predict() can only run after run() has successfully trained the regresion model.
        """
        
        # Check that run() has already been called
        if self.regression is None:
            print("The regression model seems to be missing. Have you called run() yet?")
            return
        
        # Try to make the prediction; except if dataset_X isn't a valid input
        try:
            y_prediction = self.regression.predict(dataset_X)
        except Exception as e:
            print("The model failed to run. Check your inputs and try again.")
            print("Here is the exception message:")
            print(e)
            return
        
        print()
        print("Prediction:\n", y_prediction)
        print()

    # Helper methods

    def _create_model(self):
        """
        Runs UI for getting parameters and creating model.
        """
        print("Parameter inputs for LinRegression")

        if input("Use default parameters (Y/n)? ").lower() != "n":
            self.test_size = 0.25
            self.cv = None
            self.graph_results = False
            return LinearRegression()
        
        print("If you are unsure about a parameter, press enter to use its default value.")
        
        if input("Include a y-intercept in the model (Y/n)? ").lower() == "n":
            fit_intercept = False
        else:
            fit_intercept = True
        
        if input("Normalize the dataset (y/N)? ").lower() == "y":
            normalize = True
        else:
            normalize = False
        
        if input("Copy the dataset's features (Y/n)? ").lower() == "n":
            copy_X = False
        else:
            copy_X = True
        
        n_jobs = input("Input the number of jobs for computation: ")

        try:
            n_jobs = int(n_jobs)
        except:
            n_jobs = None
        
        self.test_size = input("What fraction of the dataset should be the testing set? Input a decimal: ")

        try:
           self.test_size = float(test_size)
        except:
            self.test_size = 0.25
        
        self.cv = input("Input the number of folds for cross validation: ")

        try:
            self.cv = int(cv)
        except:
            self.cv = None
        
        if input("Graph the results? Only univariate regression is supported (y/N): ").lower() == "y":
            self.graph_results = True
        else:
            self.graph_results = False
        
        return LinearRegression(fit_intercept=fit_intercept, normalize=normalize, copy_X=copy_X, n_jobs=n_jobs)

    def _output_results(self):
        """
        Outputs model metrics after run() finishes.
        """
        print()
        print("LinRegression Results\n")
        print("Coefficients:\n", self.coefficients)
        print("{:<20} {:<20}".format("Intercept:", self.intercept))
        print("{:<20} {:<20}".format("Mean Squared Error:", self.mean_squared_error))
        print("{:<20} {:<20}".format("R2 Score:", self.r2_score))
        print("{:<20} {:<20}".format("R Score:", self.r_score))
        print("Cross Validation Scores:\n", self.cross_val_scores)
        print("\nCall predict() to make predictions for new data.")
        print()

    def _graph_results(self, X_test, y_test, y_pred):
        """
        Graphs results of linear regression with one feature. This method only graphs two-dimensional results; thus,
        only univariate regression is supported.

        graph_results() may only run after run() has successfully run.
        """
        if self.regression is None:
            print("Regression results aren't available. Have you run run() yet?")
            return

        if self.attributes.shape[1] > 1:
            print("Graphing is supported for one feature only.")
            return

        plt.scatter(X_test, y_test, color="black")
        plt.plot(X_test, y_pred, color="blue", linewidth=3)
        plt.xticks(())
        plt.yticks(())
        plt.show()

    def _check_inputs(self):
        """
        Verifies if instance data is ready for use in linear regression model.
        """

        # Check if attributes exists
        if self.attributes is None:
            print("attributes is missing; call set_attributes(new_attributes) to fix this! new_attributes should be a",
                  "populated dataset of independent variables.")
            return False

        # Check if labels exists
        if self.labels is None:
            print("labels is missing; call set_labels(new_labels) to fix this! new_labels should be a populated dataset",
                  "of dependent variables.")
            return False

        # Check if attributes and labels have same number of rows (samples)
        if self.attributes.shape[0] != self.labels.shape[0]:
            print("attributes and labels don't have the same number of rows. Make sure the number of samples in each",
                  "dataset matches!")
            return False
        
        return True